TP Pertinence
=============

Modification de la connaissance
-------------------------------

Pour commencer, le programme s'arrête dès qu'il a considéré le burn-off: il semble soit considérer que hard-work n'est pas un problème, soit qu'il n'arrive pas à le résoudre.
En ajoutant -wire_bross dans default, le programme boucle. Et pour cause : on a à la fois une surface moche à cause de la brosse et une surface belle grâce au burn-off. Il faut donc aussi lui indiquer que wire_bross et burn-off sont incompatibles.
Ainsi, le programme nous dit que son seul problème est le tough_work, mais qu'il ne peut le résoudre sans être confronté à un problème encore moins voulu. En lui donnant -100 pour le tough_work, il peut continuer à raisonner et inférer que le filler_compound est la solution.

Déclarativité
-------------

Si par exemple on place la règle permettant d'obtenir des nice_surface à partir du filler_compound en premier, le programme la trouve tout de suite et ne se pose même pas la question du tough_work.
Cela est simplement dû au système de back-tracking de Prolog : il ira considérer toutes les possibilités dans l'ordre qui lui est donné jusqu'à satisfaire la demande.
Cela ressemble un petit peu au fonctionnement humain : un coût d'accès à une idée correspond à l'ordre dans lequel elle vient en tête. Si elle est fraiche (si par exemple elle a servi à résoudre une situation similaire il y a peu), elle viendra plus rapidement et sera naturellement avantagée par rapport aux autres solutions, surtout si elle est applicable.

Non Monotonie
-------------

La liste inscrite dans les 'causal clauses' présente des idées de solution, et induit par cela une certaine monotonie : plus on a d'idées de solution qui viennent à l'esprit, plus on a de chances de résoudre le problème et de façon différentes de le faire.
Mais une autre propriété de ce programme est que lorsque l'on ajoute une 'idée', il faut aussi prévenir le monde des conséquences d'une telle idée. On complète par cela la liste 'physical consequences', qui tend à réduire les faits déduits, en ajoutant des contraintes sur les applications des idées.
Je pense que c'est de là que vient la non monotonie du programme.

Granularité
-----------

Du point de vue du programme, une granularité trop grossière réduit la problématique à néant : c'est comme si les deux protagonistes de la conversation n'y connaissaient absolument rien au sujet, et ne pouvaient apporter que des solutions non applicables, fausses, ou dans les cas du programme, pas de solution du tout.
À l'inverse, une granularité très fine permet de trouver les solutions qui tiennent compte du plus de paramètres réels possible, et la discussion qui en découlerait opposerait deux véritables spécialistes du genre.
Le choix de la granularité dépend donc de la qualification technique que l'on veut prêter aux personnages dans le domaine lié aux problèmes soulevés.
De plus, une granularité trop fine (par exemple qui agit au niveau moléculaire) prive le processus de toute humanité, et rend la recherche de solutions extrêmement longue de part la part exponentielle de l'algorithme.

Nature de la connaissance
-------------------------

Nous avons déjà eu des exemples de connaissances qui semblent sensées et qui malgré tout donnent des résultats non pertinents, comme avec l'incompatibilité entre le burn_off et le wire_bross. Cela vient juste d'une non exhaustivité de la connaissance : on peut apporter des éléments justes, mais qui sont inutiles sans toutes les connaissances qui vont avec, et on appelle souvent cela le sens commun, ou l'avantage suprême de l'homme sur la machine.
Produire des interventions de manière stable avec une connaissance raisonnable semble possible, dès lors que la connaissance raisonnable inclue le sens commun nécessaire pour la traiter. Sinon, il faut apprendre, et ce sur une longue période.

La procédure CAN
----------------

Les phases
----------

- détection des contradictions : si on la supprime, on peut obtenir des boucles infinies comme celle qui opposait le burn_off et le wire_bross.
- tentative de solution : si on ne cherche pas à satisfaire le désir en cherchant une solution, toute la manœuvre devient caduque. Si on ne tente pas d'effectuer l'action qui peut faire évoluer le monde selon ses désirs, on ne pourra jamais savoir si cette solution a une chance de fonctionner.
- propagation sur les causes par abduction : cette étape est cruciale car elle consiste à trouver la ou les règles qui ont induit l'état de fait non voulu. On ne peut pas diagnostiquer la maladie si l'on ne peut pas faire le lien entre les symptômes et leur cause.
- abandon : comme dans toute recherche de solution, le back-tracking est important. Si l'on échoue, il faut se souvenir que l'on a abandonné cette idée pour ne plus refaire cette erreur quand on remonte dans l'arbre des solutions.
- révision : pour trouver une solution, il est parfois nécessaire de faire des compromis et de revoir certains de ses objectifs à la baisse. Par exemple, au début de l'exercice, il était moins coûteux de se fatiguer que de réussir à réparer les portes. Indiquer une recherche du moindre effort comme une priorité maximale permet de trouver d'autres solutions.
