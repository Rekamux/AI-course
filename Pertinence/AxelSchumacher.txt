TP Pertinence
=============

Modification de la connaissance
-------------------------------

Pour commencer, le programme s'arrête dès qu'il a considéré le burn-off: il semble soit considérer que hard-work n'est pas un problème, soit qu'il n'arrive pas à le résoudre.
En ajoutant -wire_bross dans default, le programme boucle. Et pour cause : on a à la fois une surface moche à cause de la brosse et une surface belle grâce au burn-off. Il faut donc aussi lui indiquer que wire_bross et burn-off sont incompatibles.
Ainsi, le programme nous dit que son seul problème est le tough_work, mais qu'il ne peut le résoudre sans être confronté à un problème encore moins voulu. En lui donnant -100 pour le tough_work, il peut continuer à raisonner et inférer que le filler_compound est la solution.

Déclarativité
-------------

Si par exemple on place la règle permettant d'obtenir des nice_surface à partir du filler_compound en premier, le programme la trouve tout de suite et ne se pose même pas la question du tough_work.
Cela est simplement dû au système de back-tracking de Prolog : il ira considérer toutes les possibilités dans l'ordre qui lui est donné jusqu'à satisfaire la demande.
Cela ressemble un petit peu au fonctionnement humain : un coût d'accès à une idée correspond à l'ordre dans lequel elle vient en tête. Si elle est fraiche (si par exemple elle a servi à résoudre une situation similaire il y a peu), elle viendra plus rapidement et sera naturellement avantagée par rapport aux autres solutions, surtout si elle est applicable.

Non Monotonie
-------------

La liste inscrite dans les 'causal clauses' présente des idées de solution, et induit par cela une certaine monotonie : plus on a d'idées de solution qui viennent à l'esprit, plus on a de chances de résoudre le problème et de façon différentes de le faire.
Mais une autre propriété de ce programme est que lorsque l'on ajoute une 'idée', il faut aussi prévenir le monde des conséquences d'une telle idée. On complète par cela la liste 'physical consequences', qui tend à réduire les faits déduits, en ajoutant des contraintes sur les applications des idées.
Je pense que c'est de là que vient la non monotonie du programme.

Granularité
-----------

Du point de vue du programme, une granularité trop grossière réduit la problématique à néant : c'est comme si les deux protagonistes de la conversation n'y connaissaient absolument rien au sujet, et ne pouvaient apporter que des solutions non applicables, fausses, ou dans les cas du programme, pas de solution du tout.
À l'inverse, une granularité très fine permet de trouver les solutions qui tiennent compte du plus de paramètres réels possible, et la discussion qui en découlerait opposerait deux véritables spécialistes du genre.
Le choix de la granularité dépend donc de la qualification technique que l'on veut prêter aux personnages dans le domaine lié aux problèmes soulevés.
De plus, une granularité trop fine (par exemple qui agit au niveau moléculaire) prive le processus de toute humanité, et rend la recherche de solutions extrêmement longue de part la part exponentielle de l'algorithme.
